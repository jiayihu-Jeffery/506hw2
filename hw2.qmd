---
title: "hw2"
format: 
  html:
    code-tools: true
    highlight-style: github
    toc: true
    toc-depth: 4
editor: visual
theme: Zephyr
---

## Problem 1 - Modified Random walk {#problem-1---modified-random-walk}

Consider a 1-dimensional random walk with the following rules:

1.  Start at 0.
2.  At each step, move +1 or -1 with 50/50 probability.
3.  If +1 is chosen, 5% of the time move +10 instead.
4.  If -1 is chosen, 20% of the time move -3 instead.
5.  Repeat steps 2-4 \\(n\\) times.

(Note that if the +10 is chosen, it’s not +1 then +10, it is just +10.)

Write a function to determine the end position of this random walk.

The input and output should be:

-   Input: The number of steps

-   Output: The final position of the walk

    > random_walk(10)
    >
    > \[1\] 4

    > random_walk(10)
    >
    > \[1\] -11

We’re going to implement this in different ways and compare them.

### a.

Implement the random walk in these three versions:

-   Version 1: using a loop.
-   Version 2: using built-in R vectorized functions. (Using no loops.) (Hint: Does the order of steps matter?)
-   Version 3: Implement the random walk using one of the “`apply`” functions.

Demonstrate that all versions work by running the following:

```         
random_walk1(10)
random_walk2(10)
random_walk3(10)
random_walk1(1000)
random_walk2(1000)
random_walk3(1000)
```

#### Version 1: for-loop

```{r}
random_walk1 <- function(n) {
  position <- 0
  for (i in 1:n) {
    # decide + or -
    direction <- sample(c(1, -1), 1)
    
    #when +, 5% change to 10
    if (direction == 1) {
      step <- sample(c(1, 10), 1, prob = c(0.95, 0.05))
    } 
    
    #when -, 20% change to -3
    else {
      step <- sample(c(-1, -3), 1, prob = c(0.8, 0.2))
    }
    position <- position + step
  }
  return(position)
}
```

#### Version 2: vectorized functions (no loops)

We can calculate the overall probability of each of the four possible outcomes:

$$
\begin{aligned}
P(+1) &= P(\text{positive direction}) \times P(+1 \mid \text{positive}) = 0.5 \times 0.95 = 0.475 \\
P(+10) &= P(\text{positive direction}) \times P(+10 \mid \text{positive}) = 0.5 \times 0.05 = 0.025 \\
P(-1) &= P(\text{negative direction}) \times P(-1 \mid \text{negative}) = 0.5 \times 0.80 = 0.4 \\
P(-3) &= P(\text{negative direction}) \times P(-3 \mid \text{positive}) = 0.5 \times 0.20 = 0.1
\end{aligned}
$$

```{r}
random_walk2 <- function(n) {
  #compose all_steps as a vector, [1] indicate the first step we move how far.
  all_steps <- sample(c(1, 10, -1, -3), 
                      size = n, 
                      replace = TRUE, 
                      prob = c(0.475, 0.025, 0.4, 0.1))
  return(sum(all_steps))
}

```

#### Version 3: vapply (professor said it's safest apply function)

```{r}
random_walk3 <- function(n) {
  next_step <- function(dummy_var) {
    direction <- sample(c(1, -1), 1)
    if (direction == 1) {
      return(sample(c(1, 10), 1, prob = c(0.95, 0.05)))
    } else {
      return(sample(c(-1, -3), 1, prob = c(0.80, 0.20)))
    }
  }
  
  # Use vapply with numeric(1) as the expected return type
  all_steps <- vapply(1:n, next_step, numeric(1))
  
  final_position <- sum(all_steps)
  return(final_position)
}
```

#### Demonstration

```{r}
random_walk1(10)
random_walk2(10)
random_walk3(10)
random_walk1(1000)
random_walk2(1000)
random_walk3(1000)
```

### b.

Demonstrate that the three versions can give the same result.Show this for both `n=10` and `n=1000`. (You will need to add a way to control the randomization.)

```{r}


```

### c.

Use the **microbenchmark** package to clearly demonstrate the speed of the implementations.Compare performance with a low input (1,000) and a large input (100,000). Discuss the results.

```{r}


```

### d.

What is the probability that the random walk ends at 0 if the number of steps is 10? 100? 1000? Defend your answers with evidence based upon a Monte Carlo simulation.

```{r}


```

## Problem 2 - Mean of Mixture of Distributions {#problem-2---mean-of-mixture-of-distributions}

The number of cars passing an intersection is a classic example of a Poisson distribution. At a particular intersection, Poisson is an appropriate distribution most of the time, but during rush hours (hours of 8am and 5pm) the distribution is really normally distributed with a much higher mean.

Using a Monte Carlo simulation, estimate the average number of cars that pass an intersection under the following assumptions:

-   From midnight until 7 AM, the distribution of cars per hour is Poisson with mean 1.
-   From 9am to 4pm, the distribution of cars per hour is Poisson with mean 8.
-   From 6pm to 11pm, the distribution of cars per hour is Poisson with mean 12.
-   During rush hours (8am and 5pm), the distribution of cars per hour is Normal with mean 60 and variance 12

Accomplish this **without using any loops**.

(Hint: This can be done with extremely minimal code.)

```{r}

```

## Problem 3 - Linear Regression {#problem-3---linear-regression}

Use the following code to download the YouTube Superbowl commercials data:

```         
youtube <- read.csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-03-02/youtube.csv')
```

Information about this data can be found at <https://github.com/rfordatascience/tidytuesday/tree/main/data/2021/2021-03-02>. The research question for this project is to decide which of several attributes, if any, is associated with increased YouTube engagement metrics.

### a.

Often in data analysis, we need to [de-identify](https://en.wikipedia.org/wiki/De-identification) it. This is more important for studies of people, but let’s carry it out here. Remove any column that might uniquely identify a commercial. This includes but isn’t limited to things like brand, any URLs, the YouTube channel, or when it was published.

Report the dimensions of the data after removing these columns.

```{r}

```

### b.

For each of the following variables, examine their distribution. Determine whether i) The variable could be used as is as the outcome in a linear regression model, ii) The variable can use a transformation prior to being used as the outcome in a linear regression model, or iii) The variable would not be appropriate to use as the outcome in a linear regression model.

For each variable, report which category it falls in. If it requires a transformation, carry such a transformation out and *use that transformation going forward*.

-   View counts
-   Like counts
-   Dislike counts
-   Favorite counts
-   Comment counts

(Hint: At least the majority of these variables are appropriate to use.)

```{r}

```

### c.

For each variable in part b. that are appropriate, fit a linear regression model predicting them based upon each of the seven binary flags for characteristics of the ads, such as whether it is funny. Control for year as a continuous covariate.

Discuss the results. Identify the direction of any statistically significant results.

```{r}

```

### d.

Consider only the outcome of view counts. Calculate \\(\\hat{\\beta}\\) manually (without using `lm`) by first creating a proper design matrix, then using matrix algebra to estimate \\(\\beta\\). Confirm that you get the same result as `lm` did in part c.

```{r}

```
